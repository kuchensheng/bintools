package {{ .Key }}

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/kuchensheng/bintools/json/consts"
	"github.com/kuchensheng/bintools/json/executor/check"
	"github.com/kuchensheng/bintools/json/executor/js"
	"github.com/kuchensheng/bintools/json/executor/parameter"
	"github.com/kuchensheng/bintools/json/executor/predicate"
	"github.com/kuchensheng/bintools/json/executor/server"
	"github.com/kuchensheng/bintools/json/executor/response"
	"github.com/kuchensheng/bintools/json/executor/util"
	"github.com/kuchensheng/bintools/json/model"
	"github.com/kuchensheng/bintools/tracer/trace"
	"github.com/rs/zerolog/log"
	"encoding/json"
)

var tenantId = func() string{
    var t string
    {{- if eq .TenantId "" }}
        log.Info().Msg("空租户ID")
    {{- else }}
    t = "{{ .TenantId }}"
    {{- end }}
    return t
}()

var steps = func() []model.ApixStep {
	var steps []model.ApixStep
	//将字符串内容初始化
	var strStep = `{{.ApixSteps}}`
	if err := json.Unmarshal([]byte(strStep), &steps);err != nil {
            log.Error().Msgf("步骤信息初始化失败,%v",err)
    }
	return steps
}()
var parameters = func() []model.ApixParameter {
               	var parameters []model.ApixParameter
               	//将字符串内容初始化
               	var strParameter = `{{.ApixParameters}}`
               	if err := json.Unmarshal([]byte(strParameter), &parameters);err != nil {
                   	log.Error().Msgf("参数初始化失败,%v",err)
                   }
               	return parameters
               }()

var stepMaps = listToMap(steps)

var responses = func() map[string]model.ApixResponse {
	responseMap := make(map[string]model.ApixResponse)
	//字符串初始化
	var strResponse = `{{.ApixResponse }}`
	if err := json.Unmarshal([]byte(strResponse), &responseMap);err != nil {
        log.Error().Msgf("响应信息初始化失败,%v",err)
    }
	return responseMap
}()

func Executor{{.Key }}(ctx *gin.Context) (any, error) {
	defer func() {
		if x := recover(); x != nil {
			log.Error().Msgf("请求执行失败,%v", x)
		}
	}()
	log.Info().Msgf("当前请求:%s,Method:%s,执行文件:[{{ .Key }}]", ctx.Request.URL.Path, ctx.Request.Method)
	if err := check.CheckTenantId(ctx,tenantId);err != nil {
        return nil,err
    }
    parameterMap := parameter.SetParameterMap(ctx)
	log.Info().Msg("链路跟踪启动...")
	tracer := trace.NewServerTracer(ctx.Request)
	log.Info().Msgf("traceId = %s", tracer.TracId)

	//必填参数检查
	if err := parameter.CheckParameter(parameters, parameterMap); err != nil {
		log.Warn().Msgf("缺少必填参数:%v", err)
		tracer.EndServerTracer(trace.WARNING, err.Error())
		return nil, err
	}
	ctx.Set(consts.RESULTMAP, make(map[string]any))
	ctx.Set(consts.TRACER, tracer)
	//执行步骤
    log.Info().Msgf("参数校验通过,开始执行逻辑流程")
	if err := executeStep(ctx, "", steps); err != nil {
		log.Warn().Msgf("流程执行失败:%v", err)
		tracer.EndServerTracer(trace.WARNING, err.Error())
		return nil, err
	}
	log.Info().Msgf("流程步骤执行完毕，开始组装结果映射...")
    return response.BuildSuccessResponse(ctx,responses)

}

func executeAll(ctx *gin.Context) error {
    {{.AllSteps}}
	return nil
}
//todo 下个迭代，这里将直接用模板生成执行代码，而不是先解析再执行
//executeStep 执行步骤
func executeStep(ctx *gin.Context, PrevId string, sts []model.ApixStep) error {
	defer deferHandler()
	subList := func(parentId string) []model.ApixStep {
		var result []model.ApixStep
		for _, st := range sts {
			if st.PrevId == parentId {
				result = append(result, st)
			}
		}
		return result
	}

	subSts := subList(PrevId)
	if len(subSts) < 1 {
		return nil
	}
	for _, step := range subSts {
		if err := runStep(step, ctx, stepMaps); err != nil {
			return err
		}
		//执行子节点
		if err := executeStep(ctx, step.GraphId, sts); err != nil {
			return err
		}
	}
	return nil
}

func listToMap(steps []model.ApixStep) map[string]model.ApixStep {
	result := make(map[string]model.ApixStep)
	for _, step := range steps {
		result[step.GraphId] = step
	}
	return result
}

func runStep(step model.ApixStep, ctx *gin.Context, stepMap map[string]model.ApixStep) error {
	log.Info().Msgf("执行步骤节点:%s", step.GraphId)

	if step.Language == "javascript" {
	    // 执行JS脚本内容
    	if e := js.ExecuteJavaScript(ctx, step.Script.Script, step.GraphId); e != nil {
            return e
        }
	} else if step.Predicate != nil {
	    //执行判断逻辑
    	if ok, e := predicate.ExecPredicates(ctx, step.Predicate, step.PredicateType); e != nil {
    		return e
    	} else {
    		nextStep := stepMap[step.ThenGraphId]
    		if !ok {
    			nextStep = stepMap[step.ElseGraphId]
    		}
    		if e = runStep(nextStep, ctx, stepMap); e != nil {
    			return e
    		}
    	}
	} else {
		//执行普通的服务请求
        if e := server.ExecServer(ctx, step); e != nil {
            return e
        }
	}
	return nil
}

func deferHandler() error {
	if x := recover(); x != nil {
		return x.(error)
	}
	return nil
}
